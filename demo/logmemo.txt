------------------------------------------------
1단계 : 프로젝트 생성 및 기본 구조 설정
------------------------------------------------
 의존성, application.properties - server.port=8090  실행 확인

------------------------------------------------
2단계 : 도메인 및 회원가입 구현
------------------------------------------------
Entity, Repository, Dto작성
UserRestController
 - /join 구현
SecurityConfig
	BCryptPasswordEncoder PasswordEncoder
	SecurityFilterChain - /join, /login 권한 없이 접근가능
	filterChain	어떤 요청이 인증이 필요한지 설정하는 부분
	.csrf().disable()	REST API에서는 CSRF 비활성화하는 것이 일반적

포스트맨으로 
POST http://localhost:8090/join
Content-Type: application/json

{
  "username": "testuser",
  "password": "1234"
}

테스트



---------------------------
3단계 로그인 구현
---------------------------
PrincipalDetails.java
 우리가 만든 User 객체를 Spring Security에서 사용할 수 있도록 감싸주는 클래스
 Spring Security는 로그인 후 내부적으로 이 객체를 기반으로 인증된 사용자 정보를 처리

PrincipalDetailsService
  Spring Security는 로그인을 처리할 때 내부적으로 
  UserDetailsService의 loadUserByUsername() 메서드를 호출한다.
  그래서 우리는 UserDetailsService를 상속해서 커스터마이징 해야함.

---------------------------
4단계: SecurityConfig 보완
---------------------------
AuthenticationManager 등록
formLogin 생략하고 → /login은 우리가 만든 컨트롤러 또는 필터로 처리 예정
JWT 전용 필터를 붙일 준비

SecurityConfig
 AuthenticationManager authenticationManager
  로그인 시 사용자 검증에 사용되는 핵심 객체

내부 동작 흐름
1. 사용자가 /login 으로 POST 요청
2. UsernamePasswordAuthenticationFilter 가 가로챔
3. SecurityConfig → AuthenticationManager 호출
4. → PrincipalDetailsService.loadUserByUsername()
5. → DB에서 사용자 조회 → PrincipalDetails로 반환
6. → 인증 성공 시 SecurityContext에 사용자 등록


---------------------------
5단계: JWT 로그인 API 구현
---------------------------
목표
 사용자가 /api/login으로 아이디/비밀번호 전송
 우리가 만든 인증 로직으로 로그인 검증
 성공 시 → AccessToken 발급, RefreshToken은 Redis에 저장 예정
 React에서는 AccessToken을 쿠키 또는 localStorage에 저장하여 인증 유 지

전체 흐름
 bash
 코드 복사
 POST /api/login
  → AuthenticationManager로 인증 시도
    → PrincipalDetailsService.loadUserByUsername()
    → 인증 성공 시 JwtTokenProvider.generateToken()
    → AccessToken(쿠키), RefreshToken(레디스) 처리
    → 응답: 로그인 성공


----------
Step 1: JwtTokenProvider.java 생성
----------
JWT 토큰을 생성하고, 검증하고, 파싱하는 역할을 담당하는 클래스

그 다음 스탭 /api/login API를 UserRestController에 직접 만들어서
AuthenticationManager로 로그인 인증 → 이 클래스에서 토큰 발급까지 연결하는 작업할 차례


----------
Step 2: /api/login API 구현
----------
Spring Security가 기본 제공하는 /login 말고
직접 만든 REST API(/api/login)에서 토큰 발급하고 응답하는 흐름

목표
 사용자가 JSON 형식으로 로그인 요청(username, password)
 AuthenticationManager로 검증
 성공 시 → JwtTokenProvider로 AccessToken 생성
 AccessToken을 쿠키에 담아 응답


--
UserRestController에 /api/login 추가 

AuthenticationManager	- Spring Security가 인증 시 사용하는 핵심 객체
UsernamePasswordAuthenticationToken -	 사용자 ID/PW를 담는 인증 요청 객체
JwtTokenProvider.generateAccessToken() - 로그인 성공 시 토큰 생성
Cookie accessToken - 클라이언트에 토큰 전달 (HttpOnly로 보안 유지)

포스트맨
POST http://localhost:8090/join
Content-Type: application/json

{
  "username": "testuser",
  "password": "1234"
}


다음 단계 
우리가 만든 accessToken을
클라이언트가 요청 시마다 쿠키에 자동 포함하게 하고
백엔드에서는 해당 토큰을 검증해 인증 상태를 유지
하도록 하기



---------------------------
6단계: JwtAuthorizationFilter
---------------------------
목표
 요청에 포함된 accessToken 쿠키에서 JWT 추출
 유효한 토큰인지 검사
 토큰이 유효하면 사용자 인증 객체(Authentication)를 생성하여 SecurityContext에 등록


----------
Step 1: JwtAuthorizationFilter.java 생성
----------
매 요청마다 실행되는 JWT 인증 필터

요청에서 accessToken 쿠키 찾기,
토큰이 존재하고 유요하면,
토큰에서 username 추출, 사용자 정보 조회, 인증 객체 생성, SecurityContext에 인증 정보 등록

다음 단계
SecurityConfig에서 필터로 등록해줘야 실제로 작동함.



----------
Step 2: SecurityConfig.java에 필터 등록
----------
작성한 JwtAuthorizationFilter를 Spring Security 필터 체인에 등록해야 요청마다 자동으로 JWT 인증 처리가 작동하게 됨.

SequrityConfig.java

코드 추가

@EnableWebSecurity
@RequiredArgsConstructor

    private final PrincipalDetailsService principalDetailsService;
    private final JwtTokenProvider jwtTokenProvider;

                .addFilterBefore(
                        new JwtAuthorizationFilter(jwtTokenProvider, principalDetailsService),
                        UsernamePasswordAuthenticationFilter.class
                );


다음 단계
/api/user/me 같은 인증 테스트용 API를 만들어서
JwtAuthorizationFilter가 작동하는지 확인하기


----------
Step3: /api/user/me API 구현
----------
 로그인 후 accessToken 쿠키가 자동 포함된 상태에서
 /api/user/me 요청을 보내면
 JwtAuthorizationFilter가 작동하여 SecurityContext에 인증 정보 주입
 그 인증 정보를 꺼내 사용자 정보를 반환

UserRestController.java 코드 추가
/api/user/me

테스트 방법
 Postman에서 /api/login 요청 → accessToken 쿠키 저장됨
 Postman에서 GET http://localhost:8090/api/user/me 요청
 Cookies 탭에 accessToken이 자동 포함되어야 함
 응답: "인증된 사용자: testuser"가 나오면 성공

콘솔 확인법(디버깅)

JwtAuthorizationFilter.java
JwtTokenProvider
//콘솔 /api/user/me 작동 디버깅  주석 아래코드

